# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

.cpp_convolve <- function(xa, xb) {
    .Call('_cvxr_cpp_convolve', PACKAGE = 'cvxr', xa, xb)
}

#' Get the \code{sparse} flag field for the LinOp object
#'
#' @param xp the LinOpVector Object XPtr
#' @param v the \code{id_to_col} named int vector in R with integer names
#' @return a XPtr to ProblemData Object
.build_matrix_0 <- function(xp, v) {
    .Call('_cvxr_build_matrix_0', PACKAGE = 'cvxr', xp, v)
}

#' Get the \code{sparse} flag field for the LinOp object
#'
#' @param xp the LinOpVector Object XPtr
#' @param v1 the \code{id_to_col} named int vector in R with integer names
#' @param v2 the \code{constr_offsets} vector of offsets (an int vector in R)
#' @return a XPtr to ProblemData Object
.build_matrix_1 <- function(xp, v1, v2) {
    .Call('_cvxr_build_matrix_1', PACKAGE = 'cvxr', xp, v1, v2)
}

#' Create a new LinOp object.
#'
#' @return an external ptr (Rcpp::XPtr) to a LinOp object instance.
.LinOp__new <- function() {
    .Call('_cvxr_LinOp__new', PACKAGE = 'cvxr')
}

#' Get the \code{sparse} flag field for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return TRUE or FALSE
.LinOp__get_sparse <- function(xp) {
    .Call('_cvxr_LinOp__get_sparse', PACKAGE = 'cvxr', xp)
}

#' Set the flag \code{sparse} of the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param sparseSEXP an R boolean
.LinOp__set_sparse <- function(xp, sparseSEXP) {
    invisible(.Call('_cvxr_LinOp__set_sparse', PACKAGE = 'cvxr', xp, sparseSEXP))
}

#' Get the field named \code{sparse_data} from the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return a \link[Matrix]{dgCMatrix-class} object
.LinOp__get_sparse_data <- function(xp) {
    .Call('_cvxr_LinOp__get_sparse_data', PACKAGE = 'cvxr', xp)
}

#' Set the field named \code{sparse_data} of the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param sparseMat a \link[Matrix]{dgCMatrix-class} object
.LinOp__set_sparse_data <- function(xp, sparseMat) {
    invisible(.Call('_cvxr_LinOp__set_sparse_data', PACKAGE = 'cvxr', xp, sparseMat))
}

#' Get the field \code{dense_data} for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return a MatrixXd object
.LinOp__get_dense_data <- function(xp) {
    .Call('_cvxr_LinOp__get_dense_data', PACKAGE = 'cvxr', xp)
}

#' Set the field \code{dense_data} of the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param denseMat a standard matrix object in R
.LinOp__set_dense_data <- function(xp, denseMat) {
    invisible(.Call('_cvxr_LinOp__set_dense_data', PACKAGE = 'cvxr', xp, denseMat))
}

#' Get the field \code{size} for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return an integer vector
.LinOp__get_size <- function(xp) {
    .Call('_cvxr_LinOp__get_size', PACKAGE = 'cvxr', xp)
}

#' Set the field \code{size} of the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param value an integer vector object in R
.LinOp__set_size <- function(xp, value) {
    invisible(.Call('_cvxr_LinOp__set_size', PACKAGE = 'cvxr', xp, value))
}

#' Perform a push back operation on the \code{args} field of LinOp
#'
#' @param xp the LinOp Object XPtr
#' @param yp the LinOp Object XPtr to push
.LinOp__args_push_back <- function(xp, yp) {
    invisible(.Call('_cvxr_LinOp__args_push_back', PACKAGE = 'cvxr', xp, yp))
}

#' Perform a push back operation on the \code{size} field of LinOp
#'
#' @param xp the LinOp Object XPtr
#' @param intVal the integer value to push back
.LinOp__size_push_back <- function(xp, intVal) {
    invisible(.Call('_cvxr_LinOp__size_push_back', PACKAGE = 'cvxr', xp, intVal))
}

#' Set the field named \code{type} for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @param typeValue an integer value
.LinOp__set_type <- function(xp, typeValue) {
    invisible(.Call('_cvxr_LinOp__set_type', PACKAGE = 'cvxr', xp, typeValue))
}

#' Get the field named \code{type} for the LinOp object
#'
#' @param xp the LinOp Object XPtr
#' @return an integer value for type
.LinOp__get_type <- function(xp) {
    .Call('_cvxr_LinOp__get_type', PACKAGE = 'cvxr', xp)
}

#' Perform a push back operation on the \code{slice} field of LinOp
#'
#' @param xp the LinOp Object XPtr
#' @param intVec an integer vector to push back
.LinOp__slice_push_back <- function(xp, intVec) {
    invisible(.Call('_cvxr_LinOp__slice_push_back', PACKAGE = 'cvxr', xp, intVec))
}

#' Get the slice field of the LinOp Object
#'
#' @param xp the LinOp Object XPtr
#' @return the value of the slice field of the LinOp Object
.LinOp__get_slice <- function(xp) {
    .Call('_cvxr_LinOp__get_slice', PACKAGE = 'cvxr', xp)
}

#' Set the slice field of the LinOp Object
#'
#' @param xp the LinOp Object XPtr
#' @param value a list of integer vectors, e.g. \code{list(1:10, 2L, 11:15)}
#' @return the value of the slice field of the LinOp Object
.LinOp__set_slice <- function(xp, value) {
    invisible(.Call('_cvxr_LinOp__set_slice', PACKAGE = 'cvxr', xp, value))
}

#' Get the id field of the LinOp Object
#'
#' @param xp the LinOp Object XPtr
#' @return the value of the id field of the LinOp Object
.LinOp__get_id <- function(xp) {
    .Call('_cvxr_LinOp__get_id', PACKAGE = 'cvxr', xp)
}

#' Create a new LinOpVector object.
#'
#' @return an external ptr (Rcpp::XPtr) to a LinOp object instance.
.LinOpVector__new <- function() {
    .Call('_cvxr_LinOpVector__new', PACKAGE = 'cvxr')
}

#' Perform a push back operation on the \code{args} field of LinOp
#'
#' @param xp the LinOpVector Object XPtr
#' @param yp the LinOp Object XPtr to push
.LinOpVector__push_back <- function(xp, yp) {
    invisible(.Call('_cvxr_LinOpVector__push_back', PACKAGE = 'cvxr', xp, yp))
}

#' Return the LinOp element at index i (0-based)
#'
#' @param lvec the LinOpVector Object XPtr
#' @param i the index
.LinOp_at_index <- function(lvec, i) {
    .Call('_cvxr_LinOp_at_index', PACKAGE = 'cvxr', lvec, i)
}

#' Create a new ProblemData object.
#'
#' @return an external ptr (Rcpp::XPtr) to a ProblemData object instance.
.ProblemData__new <- function() {
    .Call('_cvxr_ProblemData__new', PACKAGE = 'cvxr')
}

#' Get the V field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @return a numeric vector of doubles (the field V) from the ProblemData Object
.ProblemData__get_V <- function(xp) {
    .Call('_cvxr_ProblemData__get_V', PACKAGE = 'cvxr', xp)
}

#' Set the V field in the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param vp a numeric vector of values for field V
.ProblemData__set_V <- function(xp, vp) {
    invisible(.Call('_cvxr_ProblemData__set_V', PACKAGE = 'cvxr', xp, vp))
}

#' Get the I field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @return an integer vector of the field I from the ProblemData Object
.ProblemData__get_I <- function(xp) {
    .Call('_cvxr_ProblemData__get_I', PACKAGE = 'cvxr', xp)
}

#' Set the I field in the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param ip an integer vector of values for field I of the ProblemData object
.ProblemData__set_I <- function(xp, ip) {
    invisible(.Call('_cvxr_ProblemData__set_I', PACKAGE = 'cvxr', xp, ip))
}

#' Get the J field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @return an integer vector of the field J from the ProblemData Object
.ProblemData__get_J <- function(xp) {
    .Call('_cvxr_ProblemData__get_J', PACKAGE = 'cvxr', xp)
}

#' Set the J field in the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param jp an integer vector of the values for field J of the ProblemData object
.ProblemData__set_J <- function(xp, jp) {
    invisible(.Call('_cvxr_ProblemData__set_J', PACKAGE = 'cvxr', xp, jp))
}

#' Get the const_vec field from the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @return a numeric vector of the field const_vec from the ProblemData Object
.ProblemData__get_const_vec <- function(xp) {
    .Call('_cvxr_ProblemData__get_const_vec', PACKAGE = 'cvxr', xp)
}

#' Set the const_vec field in the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param cvp a numeric vector of values for const_vec field of the ProblemData object
.ProblemData__set_const_vec <- function(xp, cvp) {
    invisible(.Call('_cvxr_ProblemData__set_const_vec', PACKAGE = 'cvxr', xp, cvp))
}

#' Get the id_to_col field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @return the id_to_col field as a named integer vector where the names are integers converted to characters
.ProblemData__get_id_to_col <- function(xp) {
    .Call('_cvxr_ProblemData__get_id_to_col', PACKAGE = 'cvxr', xp)
}

#' Set the id_to_col field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param iv a named integer vector with names being integers converted to characters
.ProblemData__set_id_to_col <- function(xp, iv) {
    invisible(.Call('_cvxr_ProblemData__set_id_to_col', PACKAGE = 'cvxr', xp, iv))
}

#' Get the const_to_row field of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @return the const_to_row field as a named integer vector where the names are integers converted to characters
.ProblemData__get_const_to_row <- function(xp) {
    .Call('_cvxr_ProblemData__get_const_to_row', PACKAGE = 'cvxr', xp)
}

#' Set the const_to_row map of the ProblemData Object
#'
#' @param xp the ProblemData Object XPtr
#' @param iv a named integer vector with names being integers converted to characters
.ProblemData__set_const_to_row <- function(xp, iv) {
    invisible(.Call('_cvxr_ProblemData__set_const_to_row', PACKAGE = 'cvxr', xp, iv))
}

