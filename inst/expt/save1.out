
R version 3.4.1 (2017-06-30) -- "Single Candle"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin15.6.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> > if(identical(getOption('pager'), file.path(R.home('bin'), 'pager'))) # rather take the ESS one
+       options(pager='cat')
> options(STERM='iESS', str.dendrogram.last="'", editor='emacsclient', show.error.locations=TRUE)
> x <- Variable(2)
Error in Variable(2) : could not find function "Variable"
> library(cvxr)
x <- Variable(2)

Attaching package: ‘cvxr’

The following objects are masked from ‘package:stats’:

    decompose, reshape

The following objects are masked from ‘package:base’:

    split, trace

Warning messages:
1: replacing previous import ‘Matrix::crossprod’ by ‘gmp::crossprod’ when loading ‘cvxr’ 
2: replacing previous import ‘Matrix::tcrossprod’ by ‘gmp::tcrossprod’ when loading ‘cvxr’ 
> > P <- diag(2)
> obj <- MatrixFrac(x, P)
> prob <- Problem(Minimize(obj))
> d <- get_problem_data(prob, "ECOS")
Loading required package: ECOSolveR

Attaching package: ‘ECOSolveR’

The following object is masked from ‘package:cvxr’:

    ecos.control

Error in Solver._reject_problem(solver, "it cannot solve semidefinite problems") : 
  The solver ECOS cannot solve the problem because it cannot solve semidefinite problems
> d <- get_problem_data(prob, "SCS")
Loading required package: scs
Loading required package: Matrix
Before Build Matrix 1
Processing constraint 0
After constructing external ptr
Instantiating ProblemData-R6 
Before Build Matrix 1
Processing constraint 0
Processing constraint 1
Processing constraint 2
Processing constraint 3
Processing constraint 4
After constructing external ptr
Instantiating ProblemData-R6 
> d
$c
 [1] 0 0 0 0 0 0 0 0 0 0 0 1

$offset
[1] 0

$A
16 x 12 sparse Matrix of class "dgCMatrix"
                                                           
 [1,]  .  .  1  .         .        .  .  .        . .  .  .
 [2,]  .  .  .  .         .        .  .  .        . .  .  .
 [3,]  .  .  .  .         .        .  .  .        . .  .  .
 [4,]  .  .  .  .         .        .  .  .        . .  .  .
 [5,] -1  .  .  .         .        .  .  .        1 .  .  .
 [6,]  . -1  .  .         .        .  .  .        . .  .  .
 [7,]  .  .  .  .         .        .  .  .        . .  1 -1
 [8,]  .  .  . -1.000000  .        1  .  .        . .  .  .
 [9,]  .  .  .  .        -1.000000 .  .  .        1 .  .  .
[10,]  .  .  .  .         .        .  . -1.000000 . 1  .  .
[11,]  .  . -1  .         .        .  .  .        . .  .  .
[12,]  .  .  . -1.414214  .        .  .  .        . .  .  .
[13,]  .  .  .  .        -1.414214 .  .  .        . .  .  .
[14,]  .  .  .  .         .        . -1  .        . .  .  .
[15,]  .  .  .  .         .        .  . -1.414214 . .  .  .
[16,]  .  .  .  .         .        .  .  .        . . -1  .

$b
 [1] 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0

$G
0 x 12 sparse Matrix of class "ngCMatrix"
                

$h
numeric(0)

$dims
$dims$f
[1] 10

$dims$l
[1] 0

$dims$ep
[1] 0

$dims$s
[1] 3


$bool_vars_idx
list()

$int_vars_idx
list()

> debug(get_problem_matrix)
> result <- solve(prob)
debugging in: get_problem_matrix(active_constr, object@sym_data@.var_offsets, 
    constr_offsets)
debug: {
    cvxCanon <- CVXcanon$new()
    linOps <- lapply(constrs, function(constr) {
        constr$expr
    })
    lin_vec <- CVXcanon.LinOpVector$new()
    id_to_col_C <- id_to_col
    storage.mode(id_to_col_C) <- "integer"
    tmp <- R6List$new()
    for (lin in linOps) {
        tree <- build_lin_op_tree(lin, tmp)
        tmp$append(tree)
        lin_vec$push_back(tree)
    }
    if (typeof(constr_offsets) != "integer") {
        stop("get_problem_matrix: expecting integer vector for constr_offsets")
    }
    if (length(constr_offsets) == 0) 
        problemData <- cvxCanon$build_matrix(lin_vec, id_to_col_C)
    else {
        constr_offsets_C <- constr_offsets
        storage.mode(constr_offsets_C) <- "integer"
        problemData <- cvxCanon$build_matrix(lin_vec, id_to_col_C, 
            constr_offsets_C)
    }
    list(V = problemData$getV(), I = problemData$getI(), J = problemData$getJ(), 
        const_vec = matrix(problemData$getConstVec(), ncol = 1))
}
Browse[2]> n
debug: cvxCanon <- CVXcanon$new()
Browse[2]> n
debug: linOps <- lapply(constrs, function(constr) {
    constr$expr
})
Browse[2]> n
debug: lin_vec <- CVXcanon.LinOpVector$new()
Browse[2]> n
debug: id_to_col_C <- id_to_col
Browse[2]> n
debug: storage.mode(id_to_col_C) <- "integer"
Browse[2]> n
debug: tmp <- R6List$new()
Browse[2]> n
debug: for (lin in linOps) {
    tree <- build_lin_op_tree(lin, tmp)
    tmp$append(tree)
    lin_vec$push_back(tree)
}
Browse[2]> n
debug: tree <- build_lin_op_tree(lin, tmp)
Browse[2]> n
debug: tmp$append(tree)
Browse[2]> n
debug: lin_vec$push_back(tree)
Browse[2]> n
debug: if (typeof(constr_offsets) != "integer") {
    stop("get_problem_matrix: expecting integer vector for constr_offsets")
}
Browse[2]> n
debug: if (length(constr_offsets) == 0) problemData <- cvxCanon$build_matrix(lin_vec, 
    id_to_col_C) else {
    constr_offsets_C <- constr_offsets
    storage.mode(constr_offsets_C) <- "integer"
    problemData <- cvxCanon$build_matrix(lin_vec, id_to_col_C, 
        constr_offsets_C)
}
Browse[2]> n
debug: constr_offsets_C <- constr_offsets
Browse[2]> n
debug: storage.mode(constr_offsets_C) <- "integer"
Browse[2]> n
debug: problemData <- cvxCanon$build_matrix(lin_vec, id_to_col_C, constr_offsets_C)
Browse[2]> n
Before Build Matrix 1
Processing constraint 0
After constructing external ptr
Instantiating ProblemData-R6 
debug: list(V = problemData$getV(), I = problemData$getI(), J = problemData$getJ(), 
    const_vec = matrix(problemData$getConstVec(), ncol = 1))
Browse[2]> list(V = problemData$getV(), I = problemData$getI(), J = problemData$getJ(), 
    const_vec = matrix(problemData$getConstVec(), ncol = 1))
list(V = problemData$getV(), I = problemData$getI(), J = problemData$getJ(), 
+     const_vec = matrix(problemData$getConstVec(), ncol = 1))
$V
[1] 1

$I
[1] 0

$J
[1] 11

$const_vec
     [,1]
[1,]    0

Browse[2]> c
exiting from: get_problem_matrix(active_constr, object@sym_data@.var_offsets, 
    constr_offsets)
debugging in: get_problem_matrix(active_constr, object@sym_data@.var_offsets, 
    constr_offsets)
debug: {
    cvxCanon <- CVXcanon$new()
    linOps <- lapply(constrs, function(constr) {
        constr$expr
    })
    lin_vec <- CVXcanon.LinOpVector$new()
    id_to_col_C <- id_to_col
    storage.mode(id_to_col_C) <- "integer"
    tmp <- R6List$new()
    for (lin in linOps) {
        tree <- build_lin_op_tree(lin, tmp)
        tmp$append(tree)
        lin_vec$push_back(tree)
    }
    if (typeof(constr_offsets) != "integer") {
        stop("get_problem_matrix: expecting integer vector for constr_offsets")
    }
    if (length(constr_offsets) == 0) 
        problemData <- cvxCanon$build_matrix(lin_vec, id_to_col_C)
    else {
        constr_offsets_C <- constr_offsets
        storage.mode(constr_offsets_C) <- "integer"
        problemData <- cvxCanon$build_matrix(lin_vec, id_to_col_C, 
            constr_offsets_C)
    }
    list(V = problemData$getV(), I = problemData$getI(), J = problemData$getJ(), 
        const_vec = matrix(problemData$getConstVec(), ncol = 1))
}
Browse[2]> n
debug: cvxCanon <- CVXcanon$new()
Browse[2]> n
debug: linOps <- lapply(constrs, function(constr) {
    constr$expr
})
Browse[2]> n
debug: lin_vec <- CVXcanon.LinOpVector$new()
Browse[2]> n
debug: id_to_col_C <- id_to_col
Browse[2]> n
debug: storage.mode(id_to_col_C) <- "integer"
Browse[2]> n
debug: tmp <- R6List$new()
Browse[2]> n
debug: for (lin in linOps) {
    tree <- build_lin_op_tree(lin, tmp)
    tmp$append(tree)
    lin_vec$push_back(tree)
}
Browse[2]> n
debug: tree <- build_lin_op_tree(lin, tmp)
Browse[2]> n
debug: tmp$append(tree)
Browse[2]> n
debug: lin_vec$push_back(tree)
Browse[2]> n
debug: tree <- build_lin_op_tree(lin, tmp)
Browse[2]> n
debug: tmp$append(tree)
Browse[2]> n
debug: lin_vec$push_back(tree)
Browse[2]> n
debug: tree <- build_lin_op_tree(lin, tmp)
Browse[2]> n
debug: tmp$append(tree)
Browse[2]> n
debug: lin_vec$push_back(tree)
Browse[2]> n
debug: tree <- build_lin_op_tree(lin, tmp)
Browse[2]> n
debug: tmp$append(tree)
Browse[2]> n
debug: lin_vec$push_back(tree)
Browse[2]> n
debug: tree <- build_lin_op_tree(lin, tmp)
Browse[2]> n
debug: tmp$append(tree)
Browse[2]> n
debug: lin_vec$push_back(tree)
Browse[2]> n
debug: if (typeof(constr_offsets) != "integer") {
    stop("get_problem_matrix: expecting integer vector for constr_offsets")
}
Browse[2]> n
debug: if (length(constr_offsets) == 0) problemData <- cvxCanon$build_matrix(lin_vec, 
    id_to_col_C) else {
    constr_offsets_C <- constr_offsets
    storage.mode(constr_offsets_C) <- "integer"
    problemData <- cvxCanon$build_matrix(lin_vec, id_to_col_C, 
        constr_offsets_C)
}
Browse[2]> n
debug: constr_offsets_C <- constr_offsets
Browse[2]> n
debug: storage.mode(constr_offsets_C) <- "integer"
Browse[2]> n
debug: problemData <- cvxCanon$build_matrix(lin_vec, id_to_col_C, constr_offsets_C)
Browse[2]> n
Before Build Matrix 1
Processing constraint 0
Processing constraint 1
Processing constraint 2
Processing constraint 3
Processing constraint 4
After constructing external ptr
Instantiating ProblemData-R6 
debug: list(V = problemData$getV(), I = problemData$getI(), J = problemData$getJ(), 
    const_vec = matrix(problemData$getConstVec(), ncol = 1))
Browse[2]> list(V = problemData$getV(), I = problemData$getI(), J = problemData$getJ(), 
    const_vec = matrix(problemData$getConstVec(), ncol = 1))
list(V = problemData$getV(), I = problemData$getI(), J = problemData$getJ(), 
+     const_vec = matrix(problemData$getConstVec(), ncol = 1))
$V
 [1]  1.000000 -1.000000 -1.000000  1.000000  1.000000 -1.000000 -1.000000
 [8] -1.000000  1.000000 -1.000000  1.000000  1.000000 -1.000000 -1.414214
[15] -1.414214 -1.000000 -1.414214 -1.000000

$I
 [1]  0  4  5  4  6  6  7  8  7  9  8  9 10 11 12 13 14 15

$J
 [1]  2  0  1  8 10 11  3  4  5  7  8  9  2  3  4  6  7 10

$const_vec
      [,1]
 [1,]   -1
 [2,]    0
 [3,]    0
 [4,]   -1
 [5,]    0
 [6,]    0
 [7,]    0
 [8,]    0
 [9,]    0
[10,]    0
[11,]    0
[12,]    0
[13,]    0
[14,]    0
[15,]    0
[16,]    0

Browse[2]> Q
> q()

Process R finished at Mon Sep  4 08:51:55 2017
